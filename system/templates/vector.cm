typedef struct NAME { size_t length, capacity; TYPE *list; } NAME;
static inline NAME NAME_new(size_t initialCapacity)
{
	NAME this;
	this.length = 0;
	this.capacity = initialCapacity;
	this.list = malloc(sizeof(TYPE) * this.capacity);
	if (!this.list)
		err(1, "Failed to allocate NAME when constructing");
	return this;
}

static inline void NAME_resize_to_fit(NAME *this, size_t length)
{
	// already the right size
	if (length <= this->capacity)
		return;
	if (this->capacity == 0)
		this->capacity = 1;
	while (this->capacity < length)
		this->capacity *= 2;
	TYPE *newList = realloc(this->list, this->capacity);
	if (!newList)
		err(1, "Failed to reallocate NAME when resizing to fit %lu elements (new capacity %lu)", length, this->capacity);
	this->list = newList;
}

static inline void NAME_push(NAME *this, TYPE value)
{
	NAME_resize_to_fit(this, this->length + 1);
	this->list[this->length++] = value;
}

static inline TYPE NAME_pop(NAME *this)
{
	if (this->length == 0)
		errx(1, "Pop attempted from empty NAME");
	return this->list[--this->length];
}

static inline TYPE NAME_get(NAME *this, size_t index)
{
	if (index >= this->length)
		errx(1, "Attempted read from out of bounds index from NAME (%lu >= %lu)", index, this->length);
	return this->list[index];
}

static inline TYPE *NAME_getp(NAME *this, size_t index)
{
	if (index >= this->length)
		errx(1, "Attempted read from out of bounds index from NAME (%lu >= %lu)", index, this->length);
	return &this->list[index];
}

static inline void NAME_set(NAME *this, size_t index, TYPE value)
{
	if (index >= this->length)
		errx(1, "Attempted write to out of bounds index of NAME (%lu >= %lu)", index, this->length);
	this->list[index] = value;
}

static inline NAME NAME_copy(NAME *this)
{
	NAME ret;
	ret.capacity = this->capacity;
	ret.length = this->length;
	ret.list = malloc(sizeof(TYPE) * ret.capacity);
	if (!ret.list)
		err(1, "Failed to allocate when copying NAME");
	memcpy(ret.list, this->list, sizeof(TYPE) * ret.capacity);
	return ret;
}

// [startIdx, endIdx)
static inline NAME NAME_get_slice(NAME *this, size_t startIdx, size_t endIdx)
{
	NAME ret;
	ret.capacity = endIdx - startIdx;
	ret.length = endIdx - startIdx;
	if (startIdx >= this->length)
		errx(1, "Attempted slice starting at out of bounds index of NAME (%lu >= %lu)", startIdx, this->length);
	if (endIdx > this->length)
		errx(1, "Attempted slice ending at out of bounds index of NAME (%lu >= %lu)", endIdx, this->length);
	ret.list = malloc(sizeof(TYPE) * ret.capacity);
	if (!ret.list)
		err(1, "Failed to allocate when getting slice of NAME");
	for (size_t i = startIdx; i < endIdx; ++i)
		ret.list[i - startIdx] = this->list[i];
	return ret;
}

// [startIdx, endIdx)
static inline NAME NAME_remove_slice(NAME *this, size_t startIdx, size_t endIdx)
{
	NAME ret;
	ret.capacity = endIdx - startIdx;
	ret.length = endIdx - startIdx;
	if (startIdx >= this->length)
		errx(1, "Attempted slice starting at out of bounds index of NAME (%lu >= %lu)", startIdx, this->length);
	if (endIdx > this->length)
		errx(1, "Attempted slice ending at out of bounds index of NAME (%lu >= %lu)", endIdx, this->length);
	ret.list = malloc(sizeof(TYPE) * ret.capacity);
	if (!ret.list)
		err(1, "Failed to allocate when getting slice of NAME");
	for (size_t i = startIdx; i < endIdx; ++i)
		ret.list[i - startIdx] = this->list[i];
	// shift over last elements
	memmove(&this->list[startIdx], &this->list[endIdx], (this->length - endIdx) * sizeof(TYPE));
	this->length -= ret.length;
	return ret;
}

static inline TYPE NAME_remove(NAME *this, size_t index)
{
	if (index >= this->length)
		errx(1, "Attempted remove out of bounds index of NAME (%lu >= %lu)", index, this->length);
	// shift over last elements
	TYPE value = this->list[index];
	memmove(&this->list[index], &this->list[index+1], (this->length - index - 1) * sizeof(TYPE));
	--this->length;
	return value;
}

static inline void NAME_insert(NAME *this, TYPE value, size_t index)
{
	// inserting to end should be allowed, since that's just a push
	if (index == this->length) {
		NAME_push(this, value);
		return;
	}
	if (index > this->length)
		err(1, "Attempted insert to out of bounds index of NAME (%lu > %lu)", index, this->length);

	// handle expanding the list
	NAME_resize_to_fit(this, this->length + 1);
	// shift elements over to the right by one
	memmove(&this->list[index+1], &this->list[index], (this->length - index) * sizeof(TYPE));
	this->list[index] = value;
	++this->length;
}

static inline void NAME_push_slice(NAME *this, NAME *value)
{
	NAME_resize_to_fit(this, this->length + value->length);
	for (size_t i = 0; i < value->length; ++i)
		this->list[this->length++] = value->list[i];
}

static inline void NAME_insert_slice(NAME *this, NAME *value, size_t index)
{
	// inserting to end should be allowed, since that's just a push
	if (index == this->length) {
		NAME_push_slice(this, value);
		return;
	}
	if (index > this->length)
		err(1, "Attempted insert to out of bounds index of NAME (%lu > %lu)", index, this->length);

	// handle expanding the list
	NAME_resize_to_fit(this, this->length + value->length);
	// shift elements over to the right by count
	memmove(&this->list[index + value->length], &this->list[index], this->length - index);
	for (size_t i = 0; i < value->length; ++i)
		this->list[index+i] = value->list[i];
	this->length += value->length;
}

static inline void NAME_apply(NAME *this, TYPE (*func)(TYPE x))
{
	for (size_t i = 0; i < this->length; ++i)
		this->list[i] = func(this->list[i]);
}

static inline void NAME_free(NAME *this)
{
	free(this->list);
}
static inline bool NAME_equals(NAME this, NAME other)
{
	if (this.length != other.length)
		return false;
	for (size_t i = 0; i < this.length; ++i)
		if (this.list[i] != other.list[i])
			return false;
	return true;
}
